(local lu (require :luaunit))
(local csound (require :csound))

(global all {})

(fn all.setUp
  [self])

(local orc
"instr 1
  out(linen(oscili(p4,p5),0.1,p3,0.1))
 endin
")

(local mk-sco
  ;; creates a simple sco that runs for a given number of seconds
  (fn [seconds]
    (.. "i1 0 " seconds " 2000 440")))

(fn all.test-synth
  [self]
  (let [duration 5
        cs csound.cs
        csound (csound.make)
        _ (lu.assertUserdata csound)
        result (cs.csoundStart csound)
        _ (lu.assertTrue (= result 0))
        result (cs.csoundCompileOrc csound orc)
        _ (lu.assertTrue (= result 0))
        result (cs.csoundReadScore csound (mk-sco duration))
        _ (lu.assertTrue (= result 0))
        sr (cs.csoundGetSr csound)
        ksmps (cs.csoundGetKsmps csound)
        kr (cs.csoundGetKr csound)
        iteration-count (/ (* duration sr) ksmps)]
    (lu.assertTrue (= sr 44100))
    (lu.assertTrue (= ksmps (/ sr kr)))
    (lu.assertTrue (= iteration-count (* duration kr)))
    (for [i 0 iteration-count]
      (lu.assertTrue (= (cs.csoundPerformKsmps csound)
                        0)))
    (let [result (cs.csoundCleanup csound)]
      (cs.csoundDestroy csound)
      (lu.assertTrue (= result 0))
      result)))

(local runner (lu.LuaUnit.new))
(: runner :setOutputType :tap)

(os.exit (: runner :runSuite))
